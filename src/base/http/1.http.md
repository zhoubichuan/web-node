---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 一.websocket 相关知识
## 1.HTTP的架构模式
HTTP是客户端/服务器模式中请求-响应所用的协议，在这种模式中，客户端（一般是web浏览器）向服务器提交HTTP请求，服务器响应请求的资源
### 1.1 HTTP的特点

# 轮询

### 轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次

### 这种范式连接数会很多，一个接受，一个发送。而且每次发送请求都会有 http 的 header，会很耗流量，也会消耗 cpu 的利用率。

![轮询](./polling.jpg)

## 案例代码

* 客户端定时发送 ajax 请求后端接口，后端返回此时的时间

### 客户端代码

* html

```
<div id="clock"></div>
```

* js

```
let clockDiv = document.getElementById('clock')
setInterval(function () {
    let xhr = new XMLHttpRequest;
    xhr.open('GET', '/clock', true)
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && xhr.status == 200) {
            clockDiv.innerHTML = xhr.responseText
        }
    }
    xhr.send()
}, 1000)
```

### 服务端代码

```
let express = require("express");
let app=express()
app.use(express.static(__dirname))
app.get('/clock',(req,res)=>{
  res.end(new Date().toLocaleString())
})
app.listen(8080)
```

### 启动服务器，浏览器打开 http://localhost:8080/index.html

![](./result.png)
# 长轮询

### 长轮询是对轮询的改进版，客户端发送 http 给服务器之后，看有没有新消息，如果没有新消息，就一直等待。

### 当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和 cup 利用率等问题。

### 由于 http 数据包的头部数据量往往很大（通常有 400 多个字节），但是真正被服务器需要的数据却很少（有的只有 10 个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。

![](./longpolling.png)

## 案例代码

### 客户端

* html

```
<div id="clock"></div>
```

* js

```
let clockDiv = document.getElementById('clock')
function send() {
    setInterval(function () {
        let xhr = new XMLHttpRequest;
        xhr.open('GET', '/clock', true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status == 200) {
                    clockDiv.innerHTML = xhr.responseText
                }
                send()
            }
        }
        xhr.timeout = function () {
            send()
        }
        xhr.send()
    }, 1000)
}
send()
```

### 服务端

```
let express = require("express");
let app = express();
app.use(express.static(__dirname))
app.get('/clock',(req,res)=>{
  setTimeout(()=>{
    res.end(new Date().toLocaleString())
  },3000)
})
app.listen(8080);
```

### 启动服务器，浏览器打开 http://localhost:8080/index.html

![](./result.png)
# iframe

### 通过在 html 页面里嵌入一个隐藏的 iframe，然后将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地向客户端推送数据。

![](./iframeflow.png)

##案例

### 客户端代码

* html

```
<div id="clock"></div>
<iframe src="/clock" frameborder="0" style="display:none"></iframe>
```

### 服务端代码

```
let express = require("express");
let app = express();
app.use(express.static(__dirname));
app.get("/clock", (req, res) => {
  setInterval(() => {
    let date = new Date().toLocaleString();
    res.write(`
        <script type="text/javascript">
        parent.document.getElementById('clock').innerHTML="${date}"
        </script>
        `);
  }, 1000);
});
app.listen(3000, () => {
  console.log(3000);
});
```
