(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{345:function(v,_,t){v.exports=t.p+"assets/img/browser.50ecb193.jpg"},346:function(v,_,t){v.exports=t.p+"assets/img/eventloop.da078fa3.png"},347:function(v,_,t){v.exports=t.p+"assets/img/nodesystem.20c8ec0e.png"},401:function(v,_,t){"use strict";t.r(_);var a=t(9),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"二-node介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二-node介绍"}},[v._v("#")]),v._v(" 二.Node介绍")]),v._v(" "),_("ul",[_("li",[v._v("node 的首要目的是提供一种简单的，用于创建高性能服务器的开发工具")]),v._v(" "),_("li",[v._v("web 服务器的瓶颈在于并发的用户量")])]),v._v(" "),_("h2",{attrs:{id:"_1-node-的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-node-的特点"}},[v._v("#")]),v._v(" 1.Node 的特点")]),v._v(" "),_("ul",[_("li",[v._v("node.js 是一个基于 chrome v8 引擎 JavaScript 运行环境，让 JavaScript 的执行效率与低端的 c 语言有相近的执行效率")]),v._v(" "),_("li",[v._v("node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效")]),v._v(" "),_("li",[v._v("node.js 的包管理器是全球最大的开源生态系统")])]),v._v(" "),_("h3",{attrs:{id:"_1-1-为什么-javascript-是单线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-为什么-javascript-是单线程"}},[v._v("#")]),v._v(" 1.1. 为什么 JavaScript 是单线程")]),v._v(" "),_("ul",[_("li",[v._v("这个是由 JavaScript 这门语言的用途决定的")]),v._v(" "),_("li",[v._v("webwork 没有改变 JavaScript 单线程的本质")])]),v._v(" "),_("h3",{attrs:{id:"_1-2-浏览器模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-浏览器模型"}},[v._v("#")]),v._v(" 1.2. 浏览器模型")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("用户界面：地址栏、前进/后退按钮、书签菜单等。")])]),v._v(" "),_("li",[_("p",[v._v("浏览器引擎：在用户界面和呈现引擎之间传送指令。")])]),v._v(" "),_("li",[_("p",[v._v("呈现引擎：又叫渲染引擎或叫浏览器内核，在线程方面又称为 UI 线程")])]),v._v(" "),_("li",[_("p",[v._v("网络：用于网络调用，比如 HTTP 请求。")])]),v._v(" "),_("li",[_("p",[v._v("用户界面后端：用于绘制基本的窗口小部件,UI 线程和 JS 共用一个线程。")])]),v._v(" "),_("li",[_("p",[v._v("JavaScript 解释器：用于解析和执行 JavaScript 代码")])]),v._v(" "),_("li",[_("p",[v._v("数据存储：这是持久层。浏览器需要在硬盘上存储各种数据，例如 cookie")]),v._v(" "),_("p",[_("img",{attrs:{src:t(345),alt:""}})])])]),v._v(" "),_("h3",{attrs:{id:"_1-3-除-javascript-线程和-ui-线程之外的其他线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-除-javascript-线程和-ui-线程之外的其他线程"}},[v._v("#")]),v._v(" 1.3. 除 JavaScript 线程和 UI 线程之外的其他线程")]),v._v(" "),_("ul",[_("li",[v._v("浏览器事件触发线程")]),v._v(" "),_("li",[v._v("定时触发器线程")]),v._v(" "),_("li",[v._v("异步 HTTP 请求线程")])]),v._v(" "),_("h3",{attrs:{id:"_1-4-任务队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-任务队列"}},[v._v("#")]),v._v(" 1.4. 任务队列")]),v._v(" "),_("ul",[_("li",[v._v("1.所有的同步任务都在主线程上执行，形成一个执行栈")]),v._v(" "),_("li",[v._v("2.主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列中放置一个事件")]),v._v(" "),_("li",[v._v("一旦执行栈中所有的"),_("strong",[v._v("同步任务")]),v._v("执行完毕，系统就会读取"),_("strong",[v._v("任务队列")]),v._v("，看看里面又那些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行")]),v._v(" "),_("li",[v._v("主线程不断重复上面的第三部")])]),v._v(" "),_("h3",{attrs:{id:"_1-5-event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-event-loop"}},[v._v("#")]),v._v(" 1.5. Event Loop")]),v._v(" "),_("p",[v._v("主线程从"),_("strong",[v._v("任务队列")]),v._v("中读取事件，这个过程是不断的，所以整个的这种运行机制又称为 Event Loop(事件循环)")]),v._v(" "),_("p",[_("img",{attrs:{src:t(346),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"_1-6-node-js-的-event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-node-js-的-event-loop"}},[v._v("#")]),v._v(" 1.6. Node.js 的 Event Loop")]),v._v(" "),_("p",[_("img",{attrs:{src:t(347),alt:""}})]),v._v(" "),_("ul",[_("li",[v._v("1.V8 引擎解析 JavaScript 脚本")]),v._v(" "),_("li",[v._v("2.解析后的代码，调用 Node API")]),v._v(" "),_("li",[v._v("3.libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop(事件循环)，以异步的方式将任务的执行结果返回给 V8 引擎")]),v._v(" "),_("li",[v._v("4.V8 引擎再将结果返回给用户")])]),v._v(" "),_("h3",{attrs:{id:"_1-7-同步与异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-同步与异步"}},[v._v("#")]),v._v(" 1.7. 同步与异步")]),v._v(" "),_("p",[v._v("同步和异步关注的是消息通知机制")]),v._v(" "),_("ul",[_("li",[v._v("同步就是发出调用后，没有得到结果之前，有调用不返回，一旦调用返回，就得到返回值了。简而言之就是调用者主动等待这个调用结果。")]),v._v(" "),_("li",[v._v("而异步则相反，调用者在发出调用后这个调用就直接返回了，所以没有返回结果。换句话说当一个异步调用发出后，调用者不会立即得到结果，而是调用发出后，被调用者通过状态、通知或回调函数处理这个调用。")])]),v._v(" "),_("h3",{attrs:{id:"_1-8-阻塞与非阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-阻塞与非阻塞"}},[v._v("#")]),v._v(" 1.8. 阻塞与非阻塞")]),v._v(" "),_("p",[v._v("阻塞和非阻塞关注的是呈现等待调用结果（消息，返回值）时的状态")]),v._v(" "),_("ul",[_("li",[v._v("阻塞调用是指调用结果返回之前，当前线程被挂起。调用线程只有在得到结果之后才会返回。")]),v._v(" "),_("li",[v._v("非阻塞调用指在不能立即得到结果之前，该调用不会阻塞当前线程。")])]),v._v(" "),_("h3",{attrs:{id:"_1-9-组合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-组合"}},[v._v("#")]),v._v(" 1.9. 组合")]),v._v(" "),_("p",[v._v("同步异步取决于被调用者，阻塞非阻塞取决于调用者")]),v._v(" "),_("ul",[_("li",[v._v("同步阻塞")]),v._v(" "),_("li",[v._v("异步阻塞")]),v._v(" "),_("li",[v._v("同步非阻塞")]),v._v(" "),_("li",[v._v("异步非阻塞")])]),v._v(" "),_("h2",{attrs:{id:"_2-node-使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-node-使用场景"}},[v._v("#")]),v._v(" 2. Node 使用场景")]),v._v(" "),_("p",[v._v("当应用程序需要处理大量并发的输入输出，而在客户端响应之前，应用程序不需要进行非常复杂的处理")]),v._v(" "),_("ul",[_("li",[v._v("聊天服务器")]),v._v(" "),_("li",[v._v("电子商务网站")])])])}),[],!1,null,null,null);_.default=s.exports}}]);